# 函数

## 一、foo、bar、baz

在学习编程的过程中，你可能会经常看到 foo、bar、baz 这些名词：

- 它们通常被用来作为**函数、变量、文件**的名词；
- 目前已经变成了计算机编程的术语一部分，但是它们本身并没有特别的用途和意义；
- 常被称之为 “伪变量”（metasyntactic variable）

事实上，foo、bar 这些名词最早是从什么时候、地方流行起来的一直是由争论的；

- 一种说法是通过 Digital（迪吉多，数字设备公司，成立于1957 年的美国电脑公司）的手册说明流行起来的；
- 一种说法是说源自于电子学中的反转 foo 信号；
- 也有一种说法是 foo 因为出现在了一个漫画中，漫画中 foo 代表“好运”，与中文的”福“读音类似；

总之，foo、bar、baz 已经是编程领域非常常用的名词。

## 二、函数是什么

在上文中，已经介绍过 JavaScript 中一些函数的用法，比如：

- alert 函数:
  - 用于在浏览器弹出一个弹窗。
- prompt 函数:
  - 在浏览器弹窗中接收用户的输入。
- console.log 函数:
  - 在控制台输入内容。
- String / Number / Boolean 函数等
  - 用于显示的转换数据类型。

当我们在谈函数时, 到底在谈些什么?

- 函数其实就是某段代码的封装，这段代码帮助我们完成某一个功能；
- 默认情况下 JavaScript 引擎（或者说浏览器）会给我们提供一些已经实现好的函数；
- 我们也可以编写属于自己的函数；

JavaScript 中的函数，是一个 Function 类型的值，本质上是一个 Object 类型。

## 三、函数使用

函数的使用包含两个步骤：

1. 声明函数 —— 封装独立的功能。
2. 调用函数 —— 享受封装的成果。

### 1.声明函数

声明函数，在 JavaScript 中也可以称为定义函数：

- 声明函数的过程，是对某些功能的封装过程；
- 在之后的开发中，我们会根据自己的需求，定义很多自己的函数；

声明函数使用 function 关键字：这种写法称之为函数的定义。

```javascript
function 函数名() {
  封装函数的代码
  ...
}
```

函数的名命规则 2 点。

- 函数名的命名规则和变量名的命名规则相同；
  1. 只能以字母，\_，$开头，不能以数字开头。
  2. 不能使用关键字和保留字命名。
  3. 变量严格区分大小写。
- 函数要尽量做到见名知意（并且函数通常是一些行为（action），所以使用动词会更多一些）；

函数定义完后里面的代码是不会执行的，函数必须调用才会执行；

### 2.调用函数

调用函数，也可以称为函数调用：

- 调用函数是运行已声明（定义）好的函数中的代码块；
- 这些函数可以是刚刚自己封装好的某个功能函数；当然,我们也可以去使用默认提供的或者其他三方库定义好的函数；

用函数通过“`函数名()`”即可完成：比如：`test()`

函数的作用：在开发程序时，使用函数可以提高编写的效率，以及代码的重用性；

## 三、函数的参数

函数，把具有独立功能的代码块，组织为一个小模块，在需要的时候用。

函数的参数，可增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据。

- 在函数内部，把参数当做变量使用，进行需要的数据处理。
- 函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递。

函数的形参、实参：

- 形参（参数 parameter）：定义函数时，小括号中的参数，用来接收参数，在函数内部作为变量使用 。
- 实参（参数 argument）：调用函数时，小括号中的参数，用来把数据传递到函数内部。

封装一个函数计算圆的面积，保留 2 位小数。

```javascript
function getCircleArea(radius) {
  return (Math.PI * radius ** 2).toFixed(2)
}
```

### 1.arguments 参数

事实上，在函数中，有一个特别的局部变量：arguments 对象

- 默认情况下，arguments 对象是所有（非箭头）函数中都可用的局部变量；
- 该对象中，存放着所有的调用者传入的参数，从 0 位置开始，依次存放；
- arguments 变量的类型是一个 object 类型（array-like），不是一个数组，但是和数组的用法看起来很相似；
- 如果调用者传入的参数多于函数接收的参数，可以通过 arguments 对象，去获取所有的参数；

> 后续详细介绍，包括和数组之间的转化；
>
> 数组和函数也是，都是对象。

## 四、函数的返回值

回顾之前使用的 `prompt` 函数，接受参数，并且会返回用户的输入：

函数不仅仅可以有参数, 也可以有返回值：

- 使用 `return` 关键字来返回结果；
- 一旦在函数中执行 return 操作，那么当前函数会终止；
- 如果函数中没有使用 return 语句 ，那么函数有默认的返回值：undefined；
- 如果函数使用 return 语句，但是 return 后面没有任何值，那么函数的返回值也是：undefined；

## 五、函数中调用函数

在开发中，函数内部是可以调用另外一个函数的。

```javascript
function foo() {
  console.log('foo 函数被调用')
}

function bar() {
  foo()
}
bar()
```

## 六、函数递归调用

既然函数中可以调用另外一个函数，那么函数也是可以调用自己的，这就是函数的递归（Recursion）调用。

但是函数调用自己必须有结束条件，否则会产生无限调用，造成“超出栈的最大调用次数 `Uncaught RangeError: Maximum call stack size exceeded` 错误。因为，每次函数调用，都要消耗栈资源。

递归是一种重要的编程思想：将一个复杂的任务，转化成可以重复执行的相同任务；

### 1.幂函数 pow

实现一个自己的幂函数 pow（pow 单词可以表示指数的意思）。

先用 for 循环来实现；

```javascript
function pow(a, n) {
  var result = 1

  for (var i = 0, i < n i++) {
    result *= a
  }

  return result
}
```

另一种实现思路是递归实现：

- 这是因为，在数学上：x^n^ = x * x^n-1^
- 那么对于函数的调用，我们也可以进行划分：
- 这里需要有一个结束的条件，就是当 n 已经等于 1 的时候，就不需要拆分了；

所以最终的代码如下：

```javascript
function pow(x, n) {
  if (n === 0) return 1

  return x * pow(x, n - 1)
}
```

函数执行的流程图如下：

```flow
st=>start: 开始框
op=>operation: pow(x, n)
cond=>condition: x === 1 ?
op1=>operation: x * pow(x, n-1)
io=>inputoutput: x
e=>end: 结束框
st->op
op->cond
cond(yes)->io->e
cond(no)->op1->op
```

递归代码相对循环，写出来简洁清晰，但性能较低。

### 2.斐波那契数列

数列: 1 1 2 3 5 8 13 21 34 55 ... x，前两位数是 1，后面的数是前两位数之和的数列，称为斐波那契数列。

分别用递归、循环，实现传入索引，计算斐波那契数列的案例。

递归实现：

```javascript
function fibonacci(n) {
  // 特殊的情况（前两个数字）
  if (n === 1 || n === 2) return 1

  return fibonacci(n - 1) + fibonacci(n - 2)
}
```

循环实现：

```javascript
function fibonacci(n) {
  // 特殊的情况(前两个数字)
  if (n === 1 || n === 2) return 1

  // for循环的实现
  var n1 = 1
  var n2 = 1
  var result = 0

  for (var i = 3; i <= n; i++) {
    result = n1 + n2
    n1 = n2
    n2 = result
  }

  return result
}
```

## 七、var 关键字与代码块

在代码块中，定义的 var 变量，在代码块外部，也可以被访问到。

```javascript
{
  var count = 100 // var 定义的变量是没有块级作用域的
  console.log('在代码块中访问 count:', count)
}

console.log('在代码块外面访问 count:', count) // 能够访问
```

## 八、函数作用域

在 JavaScript ES5之前，中没有块级作用域的概念，仅有函数中存在作用域。

作用域（Scope），表示一些标识符的作用有效范围（所以也有被翻译为有效范围的）；

函数的作用域，表示在函数内部定义的变量，只有在函数内部可以被访问到；

## 九、函数中的局部变量、外部变量、全局变量

函数中的外部变量、局部变量的概念：

- 定义在函数内部的变量，被称之为**局部变量（Local Variables）**。
- 定义在函数外部的变量，被称之为**外部变量（Outer Variables）**。

函数中的全局变量的概念：

- 在函数之外声明的变量（在 script 中声明的），称之为**全局变量**。
- 全局变量在任何函数中都是可见的。
- 通过 var 声明的全局变量，会在 window 对象上添加一个属性；

在函数中，访问变量的顺序：优先访问自己函数中的变量，没有找到时，在外部中访问。

> 关于块级作用域、作用域链、变量提升、AO、VO、GO 等概念，我们后续将进行介绍。

## 十、函数表达式

在 JavaScript 中，函数并不是一种神奇的语法结构，而是一种特殊的值。

前面定义函数的方式，我们称之为**函数的声明（Function Declaration）**；

定义函数还有另外一种写法是**函数表达式（Function Expressions）**：

```javascript
var foo = function() {
  console.log('foo 函数')
}
```

- function 关键字后面没有函数名，函数表达式允许省略函数名。

无论函数是如何创建的，函数都是一个值，这个值的类型是一个对象（对象的概念后面介绍）。

在 JavaScript 开发中，函数是**头等公民**。

## 十一、函数声明、函数表达式

在开发中，函数的声明和函数表达式有何区别，如何选择呢？

区别一：语法不同：

- 函数声明：是在主代码流中，声明为单独的语句的函数。
- 函数表达式：是在一个表达式中，或另一个语法结构中，创建的函数。

区别二：avaScript 创建函数的时机是不同的：

- 函数声明，在函数被定义之前，它就可以被调用。
  - 这是内部算法的原故；
  - 当 JavaScript 准备运行脚本时，首先会在脚本中寻找全局函数声明，并创建这些函数；
- 函数表达式，是在代码执行到达时，被创建，并且仅从那一刻起可用。

```javascript
foo() // 正常执行
function foo() {
  console.log('foo函数被执行了~')
}

bar() // bar is not a function
var bar = function () {
  console.log('bar函数被执行了~')
}
```

开发中如何选择呢？

- 当我们需要声明一个函数时，首先考虑函数声明语法。
- 它能够为组织代码提供更多的灵活性，因为我们可以在声明这些函数之前调用这些函数。

## 十二、JavaScript 头等函数，函数式编程

**头等函数（first-class function）**又称第一级函数，是指在程序设计语言中，函数被当作**头等公民**。这意味着：

- 函数可以作为别的函数的参数、
- 函数可以作为别的函数的返回值。
- 函数可以赋值给变量，在变量中传递。
- 函数可以存储在数据结构中；

通常，我们把函数作为头等公民的编程方式（范式），称之为**函数式编程**。

JavaScript 就是符合函数式编程的语言，这个也是 JavaScript 的一大特点；

- 比如：函数可以在变量和变量之间相互进行赋值。

```javascript
function foo() {
  console.log('foo 函数执行')
}

var bar = foo
bar()
```

## 十三、高阶函数（Higher-order function）

在 JavaScript 中，高阶函数必须满足以下两个条件之一：

- 函数接受一个或多个函数作为输入。
- 函数的返回值（输出）是一个函数。

```javascript
function bar() {
  console.log('foo 函数执行')
}

function foo(fn) {
  fn()
}
bar()
```

## 十四、匿名函数（anonymous function）

在 JavaScript 中，如果在传入一个函数时，没有指定函数名称，或没有通过函数表达式指定函数对应的变量，称为匿名函数，

## 十五、回调函数（callback function）

什么是回调函数？

```javascript
function request(url, callback) {
  console.log('根据URL向服务器发送网络请求')
  console.log('需要花费比较长的时间拿到对应的结果')
  var list = ['javascript', 'javascript学习', 'JavaScript高级编程']
  callback(list)
}

function handleResult(res) {
  console.log('在handleResult中拿到结果:', res)
}

request('url', handleResult)
```

- 上面的 `handleResult` 就是回调函数。
